# 3100 국기 인식
### 사용 알고리즘
브루트 포스

### 소요 시간
40분??

### 취약점
- 조건을 반대로 생각해보기 이게 자꾸 안됨, 문제에 따르면 영역을 고르고 색깔을 선택하는 방식으로 접근하기 쉬우나
  풀이가 쉬워지는 방법은 색깔을 먼저 고르는 것임

### 실수해결과정

### 좋은 아이디어
- 3가지 구역에 대해 어떻게 해야 인접하지 않으면서, 색깔 바꾸는 최소값을 찾느냐에 매몰되어 구현 방법에 애를 먹음
- 그러나, 색깔을 먼저 정하고 그에 따라 카운팅을 한다고 접근하면 훨씬 쉽게 접근 및 구현 가능했음.
  시간효율을 줄이는 방법으로 색깔 갯수를 저장하고 그에 따라 고를 수 있는 가짓수를 정해놓음으로서 경우의 수를 줄일 수 있음

```java
package test1;

import java.util.*;
import java.io.*;

public class boj3100 {
	public static void main(String[] args) throws IOException {
		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
		char[][] board = new char[6][9];
		for (int i = 0; i < 6; i++) {
			board[i] = bf.readLine().toCharArray();
		}
		int answer = Integer.MAX_VALUE;
		
		for (char c1 = 'A'; c1 <= 'Z';c1++){
			for (char c2 = 'A'; c2 <= 'Z'; c2++) {
				if (c1 == c2) continue;
				for (char c3 = 'A'; c3 <= 'Z'; c3++) {
					if (c3 == c2) continue;
					
					int rowCnt = 0;
					int colCnt = 0;
					
					for (int x = 0; x < 9; x++) {
						for (int y = 0; y < 2; y++) {
							if (board[y][x] != c1) rowCnt++;
						}
						for (int y = 2; y < 4; y++) {
							if (board[y][x] != c2) rowCnt++;
						}
						for (int y = 4; y < 6; y++) {
							if (board[y][x] != c3) rowCnt++;
						}
					}
					
					for (int y = 0; y < 6; y++) {
						for (int x = 0; x < 3; x++) {
							if (board[y][x] != c1) colCnt++;
						}
						for (int x = 3; x < 6; x++) {
							if (board[y][x] != c2) colCnt++;
						}
						for (int x = 6; x < 9; x++) {
							if (board[y][x] != c3) colCnt++;
						}
					}
					
					answer = Math.min(answer, rowCnt);
					answer = Math.min(answer, colCnt);
					
				}
			}
		}
		
		System.out.println(answer);
	}
}

```
