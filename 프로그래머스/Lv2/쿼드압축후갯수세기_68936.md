# 쿼드압축 후 갯수 세기_49191  
- 여전히 컴공스러운 풀이를 못하고 어렵게 접근하는 듯
- 간단하게, 내가 압축하고자 하는 영역에 대해 스캔해서 압축 여부를 판단한 뒤에
  압축이 불간으하면 분할정복으로 들어가면 되는 것
- 나는 일단 분할시킨 다음에, 상위로 올라가면서 합쳐나가는 방식으로 하려 했음. 상위 단계로 올리면서 정보를 가져나가는게 더 번거로운 문제였던 것

## 취약점
- 너무 어렵게 접근했다.
  쿼드압축을 예전에 풀어본 잔상때문인가, 간단한 거 놔두고 이상하게 접근하려는듯
  첫번째 시도 : list[] 을 통해 압축되는 상태 표현 - 이러면 Y축 압축이 표현이 안됨
  두번째 시도 : 2차원 boolean 배열로 압축 여부를 가져가며, 초기 비압축 상태의 갯수에서 압축할때마다 - 하는 방식
              이러면 압축 + 압축 상태에 대해 구분이 안됨

## 코드
```java
import java.util.*;

class Solution {
    int[][] match;
    public int solution(int n, int[][] results) {
        match = new int[n + 1][n + 1];
        
        for (int[] result : results) {
            int A = result[0], B = result[1];
            match[A][B] = 1;
            match[B][A] = -1;
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                for (int k = 1; k <= n; k++) {
                    if (match[i][k] == 1 && match[k][j] == 1) {
                        match[i][j] = 1;
                        match[j][i] = -1;
                    }
                    if (match[i][k] == -1 && match[k][j] == -1) {
                        match[i][j] = -1;
                        match[j][i] = 1;
                    }
                }
            }
        }
        int answer = 0;
        
        for (int i = 1; i <= n; i++) {
            int count = 0;
            for (int j = 1; j <= n; j++) {
                if (match[i][j] == 0) continue;
                count++;
            }
            if (count == n - 1) {
                answer++;
            }
        }
        return answer;
    }   
}
```
